{"version":3,"file":"LoginFacade.js","sourceRoot":"","sources":["../../../../../../src/common/api/worker/facades/LoginFacade.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tarrayEquals,\n\tassertNotNull,\n\tBase64,\n\tbase64ToBase64Ext,\n\tbase64ToBase64Url,\n\tbase64ToUint8Array,\n\tBase64Url,\n\tbase64UrlToBase64,\n\tdefer,\n\tDeferredObject,\n\tHex,\n\thexToUint8Array,\n\tlazyAsync,\n\tneverNull,\n\tofClass,\n\tuint8ArrayToBase64,\n\tutf8Uint8ArrayToString,\n} from \"@tutao/tutanota-utils\"\nimport {\n\tChangeKdfService,\n\tChangePasswordService,\n\tCustomerService,\n\tResetFactorsService,\n\tSaltService,\n\tSecondFactorAuthService,\n\tSessionService,\n\tTakeOverDeletedAddressService,\n\tVerifierTokenService,\n} from \"../../entities/sys/Services\"\nimport { AccountType, asKdfType, CloseEventBusOption, Const, DEFAULT_KDF_TYPE, KdfType } from \"../../common/TutanotaConstants\"\nimport {\n\tChallenge,\n\tcreateChangeKdfPostIn,\n\tcreateChangePasswordPostIn,\n\tcreateCreateSessionData,\n\tcreateDeleteCustomerData,\n\tcreateResetFactorsDeleteData,\n\tcreateSaltData,\n\tcreateSecondFactorAuthDeleteData,\n\tcreateSecondFactorAuthGetData,\n\tCreateSessionReturn,\n\tcreateTakeOverDeletedAddressData,\n\tcreateVerifierTokenServiceIn,\n\tGroupInfo,\n\tGroupInfoTypeRef,\n\tRecoverCodeTypeRef,\n\tSecondFactorAuthData,\n\tSessionTypeRef,\n\tSurveyData,\n\tUser,\n\tUserTypeRef,\n} from \"../../entities/sys/TypeRefs.js\"\nimport { TutanotaPropertiesTypeRef } from \"../../entities/tutanota/TypeRefs.js\"\nimport { HttpMethod, MediaType, resolveTypeReference } from \"../../common/EntityFunctions\"\nimport { assertWorkerOrNode, isAdminClient } from \"../../common/Env\"\nimport { ConnectMode, EventBusClient } from \"../EventBusClient\"\nimport { EntityRestClient, typeRefToPath } from \"../rest/EntityRestClient\"\nimport { AccessExpiredError, ConnectionError, LockedError, NotAuthenticatedError, NotFoundError, SessionExpiredError } from \"../../common/error/RestError\"\nimport { CancelledError } from \"../../common/error/CancelledError\"\nimport { RestClient } from \"../rest/RestClient\"\nimport { EntityClient } from \"../../common/EntityClient\"\nimport { GENERATED_ID_BYTES_LENGTH, isSameId } from \"../../common/utils/EntityUtils\"\nimport type { Credentials } from \"../../../misc/credentials/Credentials\"\nimport {\n\tAes128Key,\n\taes256DecryptWithRecoveryKey,\n\tAes256Key,\n\taes256RandomKey,\n\taesDecrypt,\n\tAesKey,\n\tbase64ToKey,\n\tcreateAuthVerifier,\n\tcreateAuthVerifierAsBase64Url,\n\tencryptKey,\n\tgenerateKeyFromPassphraseBcrypt,\n\tgenerateRandomSalt,\n\tKeyLength,\n\tkeyToUint8Array,\n\tsha256Hash,\n\tTotpSecret,\n\tTotpVerifier,\n\tuint8ArrayToBitArray,\n} from \"@tutao/tutanota-crypto\"\nimport { CryptoFacade } from \"../crypto/CryptoFacade\"\nimport { InstanceMapper } from \"../crypto/InstanceMapper\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { SessionType } from \"../../common/SessionType\"\nimport { CacheStorageLateInitializer } from \"../rest/CacheStorageProxy\"\nimport { AuthDataProvider, UserFacade } from \"./UserFacade\"\nimport { LoginFailReason } from \"../../main/PageContextLoginListener.js\"\nimport { LoginIncompleteError } from \"../../common/error/LoginIncompleteError.js\"\nimport { EntropyFacade } from \"./EntropyFacade.js\"\nimport { BlobAccessTokenFacade } from \"./BlobAccessTokenFacade.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { DatabaseKeyFactory } from \"../../../misc/credentials/DatabaseKeyFactory.js\"\nimport { ExternalUserKeyDeriver } from \"../../../misc/LoginUtils.js\"\nimport { Argon2idFacade } from \"./Argon2idFacade.js\"\nimport { CredentialType } from \"../../../misc/credentials/CredentialType.js\"\nimport { KeyRotationFacade } from \"./KeyRotationFacade.js\"\nimport { encryptString } from \"../crypto/CryptoWrapper.js\"\nimport { CacheManagementFacade } from \"./lazy/CacheManagementFacade.js\"\n\nassertWorkerOrNode()\n\nexport type NewSessionData = {\n\tuser: User\n\tuserGroupInfo: GroupInfo\n\tsessionId: IdTuple\n\tcredentials: Credentials\n\tdatabaseKey: Uint8Array | null\n}\n\nexport type CacheInfo = {\n\tisPersistent: boolean\n\tisNewOfflineDb: boolean\n\tdatabaseKey: Uint8Array | null\n}\n\ninterface ResumeSessionResultData {\n\tuser: User\n\tuserGroupInfo: GroupInfo\n\tsessionId: IdTuple\n}\n\nexport const enum ResumeSessionErrorReason {\n\tOfflineNotAvailableForFree,\n}\n\nexport type InitCacheOptions = {\n\tuserId: Id\n\tdatabaseKey: Uint8Array | null\n\ttimeRangeDays: number | null\n\tforceNewDatabase: boolean\n}\n\ntype ResumeSessionSuccess = { type: \"success\"; data: ResumeSessionResultData }\ntype ResumeSessionFailure = { type: \"error\"; reason: ResumeSessionErrorReason }\ntype ResumeSessionResult = ResumeSessionSuccess | ResumeSessionFailure\n\ntype AsyncLoginState =\n\t| { state: \"idle\" }\n\t| { state: \"running\" }\n\t| {\n\t\t\tstate: \"failed\"\n\t\t\tcredentials: Credentials\n\t\t\tcacheInfo: CacheInfo\n\t  }\n\n/**\n * All attributes that are required to derive the passphrase key.\n */\nexport type PassphraseKeyData = {\n\tkdfType: KdfType\n\tsalt: Uint8Array\n\tpassphrase: string\n}\n\nexport interface LoginListener {\n\t/**\n\t * Full login reached: any network requests can be made\n\t */\n\tonFullLoginSuccess(sessionType: SessionType, cacheInfo: CacheInfo, credentials: Credentials): Promise<void>\n\n\t/**\n\t * call when the login fails for invalid session or other reasons\n\t */\n\tonLoginFailure(reason: LoginFailReason): Promise<void>\n\n\t/**\n\t * Shows a dialog with possibility to use second factor and with a message that the login can be approved from another client.\n\t */\n\tonSecondFactorChallenge(sessionId: IdTuple, challenges: ReadonlyArray<Challenge>, mailAddress: string | null): Promise<void>\n}\n\nexport class LoginFacade {\n\tprivate eventBusClient!: EventBusClient\n\t/**\n\t * Used for cancelling second factor and to not mix different attempts\n\t */\n\tprivate loginRequestSessionId: IdTuple | null = null\n\n\t/**\n\t * Used for cancelling second factor immediately\n\t */\n\tprivate loggingInPromiseWrapper: DeferredObject<void> | null = null\n\n\t/** On platforms with offline cache we do the actual login asynchronously and we can retry it. This is the state of such async login. */\n\tasyncLoginState: AsyncLoginState = { state: \"idle\" }\n\n\tconstructor(\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly loginListener: LoginListener,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly keyRotationFacade: KeyRotationFacade,\n\t\t/**\n\t\t *  Only needed so that we can initialize the offline storage after login.\n\t\t *  This is necessary because we don't know if we'll be persistent or not until the user tries to login\n\t\t *  Once the credentials handling has been changed to *always* save in desktop, then this should become obsolete\n\t\t */\n\t\tprivate readonly cacheInitializer: CacheStorageLateInitializer,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly blobAccessTokenFacade: BlobAccessTokenFacade,\n\t\tprivate readonly entropyFacade: EntropyFacade,\n\t\tprivate readonly databaseKeyFactory: DatabaseKeyFactory,\n\t\tprivate readonly argon2idFacade: Argon2idFacade,\n\t\tprivate readonly noncachingEntityClient: EntityClient,\n\t\tprivate readonly sendError: (error: Error) => Promise<void>,\n\t\tprivate readonly cacheManagementFacade: lazyAsync<CacheManagementFacade>,\n\t) {}\n\n\tinit(eventBusClient: EventBusClient) {\n\t\tthis.eventBusClient = eventBusClient\n\t}\n\n\tasync resetSession(): Promise<void> {\n\t\tthis.eventBusClient.close(CloseEventBusOption.Terminate)\n\t\tawait this.deInitCache()\n\t\tthis.userFacade.reset()\n\t}\n\n\t/**\n\t * Create session and log in. Changes internal state to refer to the logged in user.\n\t */\n\tasync createSession(\n\t\tmailAddress: string,\n\t\tpassphrase: string,\n\t\tclientIdentifier: string,\n\t\tsessionType: SessionType,\n\t\tdatabaseKey: Uint8Array | null,\n\t): Promise<NewSessionData> {\n\t\tif (this.userFacade.isPartiallyLoggedIn()) {\n\t\t\t// do not reset here because the event bus client needs to be kept if the same user is logged in as before\n\t\t\tconsole.log(\"session already exists, reuse data\")\n\t\t\t// check if it is the same user in _initSession()\n\t\t}\n\n\t\tconst { userPassphraseKey, kdfType } = await this.loadUserPassphraseKey(mailAddress, passphrase)\n\t\t// the verifier is always sent as url parameter, so it must be url encoded\n\t\tconst authVerifier = createAuthVerifierAsBase64Url(userPassphraseKey)\n\t\tconst createSessionData = createCreateSessionData({\n\t\t\taccessKey: null,\n\t\t\tauthToken: null,\n\t\t\tauthVerifier,\n\t\t\tclientIdentifier,\n\t\t\tmailAddress: mailAddress.toLowerCase().trim(),\n\t\t\trecoverCodeVerifier: null,\n\t\t\tuser: null,\n\t\t})\n\n\t\tlet accessKey: AesKey | null = null\n\n\t\tif (sessionType === SessionType.Persistent) {\n\t\t\taccessKey = aes256RandomKey()\n\t\t\tcreateSessionData.accessKey = keyToUint8Array(accessKey)\n\t\t}\n\t\tconst createSessionReturn = await this.serviceExecutor.post(SessionService, createSessionData)\n\t\tconst sessionData = await this.waitUntilSecondFactorApprovedOrCancelled(createSessionReturn, mailAddress)\n\n\t\tconst forceNewDatabase = sessionType === SessionType.Persistent && databaseKey == null\n\t\tif (forceNewDatabase) {\n\t\t\tconsole.log(\"generating new database key for persistent session\")\n\t\t\tdatabaseKey = await this.databaseKeyFactory.generateKey()\n\t\t}\n\n\t\tconst cacheInfo = await this.initCache({\n\t\t\tuserId: sessionData.userId,\n\t\t\tdatabaseKey,\n\t\t\ttimeRangeDays: null,\n\t\t\tforceNewDatabase,\n\t\t})\n\t\tconst { user, userGroupInfo, accessToken } = await this.initSession(sessionData.userId, sessionData.accessToken, userPassphraseKey)\n\n\t\tconst modernKdfType = this.isModernKdfType(kdfType)\n\t\tif (!modernKdfType) {\n\t\t\tawait this.migrateKdfType(KdfType.Argon2id, passphrase, user)\n\t\t}\n\n\t\tconst credentials = {\n\t\t\tlogin: mailAddress,\n\t\t\taccessToken,\n\t\t\tencryptedPassword: sessionType === SessionType.Persistent ? uint8ArrayToBase64(encryptString(neverNull(accessKey), passphrase)) : null,\n\t\t\tencryptedPassphraseKey: sessionType === SessionType.Persistent ? encryptKey(neverNull(accessKey), userPassphraseKey) : null,\n\t\t\tuserId: sessionData.userId,\n\t\t\ttype: CredentialType.Internal,\n\t\t}\n\t\tthis.loginListener.onFullLoginSuccess(sessionType, cacheInfo, credentials)\n\n\t\tif (!isAdminClient()) {\n\t\t\tawait this.keyRotationFacade.initialize(userPassphraseKey, modernKdfType)\n\t\t}\n\n\t\treturn {\n\t\t\tuser,\n\t\t\tuserGroupInfo,\n\t\t\tsessionId: sessionData.sessionId,\n\t\t\tcredentials: credentials,\n\t\t\t// we always try to make a persistent cache with a key for persistent session, but this\n\t\t\t// falls back to ephemeral cache in browsers. no point storing the key then.\n\t\t\tdatabaseKey: cacheInfo.isPersistent ? databaseKey : null,\n\t\t}\n\t}\n\n\t/**\n\t * Ensure that the user is using a modern KDF type, migrating if not.\n\t * @param targetKdfType the current KDF type\n\t * @param passphrase either the plaintext passphrase or the encrypted passphrase with the access token necessary to decrypt it\n\t * @param user the user we are updating\n\t */\n\tpublic async migrateKdfType(targetKdfType: KdfType, passphrase: string, user: User): Promise<void> {\n\t\tif (!Const.EXECUTE_KDF_MIGRATION) {\n\t\t\t// Migration is not yet enabled on this version.\n\t\t\treturn\n\t\t}\n\t\tconst currentPassphraseKeyData = {\n\t\t\tpassphrase,\n\t\t\tkdfType: asKdfType(user.kdfVersion),\n\t\t\tsalt: assertNotNull(user.salt, `current salt for user ${user._id} not found`),\n\t\t}\n\n\t\tconst currentUserPassphraseKey = await this.deriveUserPassphraseKey(currentPassphraseKeyData)\n\t\tconst currentAuthVerifier = createAuthVerifier(currentUserPassphraseKey)\n\n\t\tconst newPassphraseKeyData = {\n\t\t\tpassphrase,\n\t\t\tkdfType: targetKdfType,\n\t\t\tsalt: generateRandomSalt(),\n\t\t}\n\t\tconst newUserPassphraseKey = await this.deriveUserPassphraseKey(newPassphraseKeyData)\n\n\t\tconst currentUserGroupKey = this.userFacade.getCurrentUserGroupKey()\n\t\tconst pwEncUserGroupKey = encryptKey(newUserPassphraseKey, currentUserGroupKey.object)\n\t\tconst newAuthVerifier = createAuthVerifier(newUserPassphraseKey)\n\n\t\tconst changeKdfPostIn = createChangeKdfPostIn({\n\t\t\tkdfVersion: newPassphraseKeyData.kdfType,\n\t\t\tsalt: newPassphraseKeyData.salt,\n\t\t\tpwEncUserGroupKey,\n\t\t\tverifier: newAuthVerifier,\n\t\t\toldVerifier: currentAuthVerifier,\n\t\t\tuserGroupKeyVersion: String(currentUserGroupKey.version),\n\t\t})\n\t\tconsole.log(\"Migrate KDF from:\", user.kdfVersion, \"to\", targetKdfType)\n\t\tawait this.serviceExecutor.post(ChangeKdfService, changeKdfPostIn)\n\t\t// We reload the user because we experienced a race condition\n\t\t// were we do not process the User update after doing the argon2 migration from the web client.Â´\n\t\t// In order do not rework the entity processing and its initialization for new clients we\n\t\t// replace the cached instances after doing the migration\n\t\tawait (await this.cacheManagementFacade()).reloadUser()\n\t\tthis.userFacade.setUserDistKey(currentUserGroupKey.version, newUserPassphraseKey)\n\t}\n\n\t/**\n\t * Checks if the given KDF type is phased out.\n\t * @param kdfType\n\t * @private\n\t */\n\tprivate isModernKdfType(kdfType: KdfType): boolean {\n\t\t// resist the temptation to just check if it is equal to the default, because that will yield false for KDF types we don't know about yet\n\t\treturn kdfType !== KdfType.Bcrypt\n\t}\n\n\t/**\n\t * If the second factor login has been cancelled a CancelledError is thrown.\n\t */\n\tprivate waitUntilSecondFactorApprovedOrCancelled(\n\t\tcreateSessionReturn: CreateSessionReturn,\n\t\tmailAddress: string | null,\n\t): Promise<{\n\t\tsessionId: IdTuple\n\t\tuserId: Id\n\t\taccessToken: Base64Url\n\t}> {\n\t\tlet p = Promise.resolve()\n\t\tlet sessionId = [this.getSessionListId(createSessionReturn.accessToken), this.getSessionElementId(createSessionReturn.accessToken)] as const\n\t\tthis.loginRequestSessionId = sessionId\n\n\t\tif (createSessionReturn.challenges.length > 0) {\n\t\t\t// Show a message to the user and give them a chance to complete the challenges.\n\t\t\tthis.loginListener.onSecondFactorChallenge(sessionId, createSessionReturn.challenges, mailAddress)\n\n\t\t\tp = this.waitUntilSecondFactorApproved(createSessionReturn.accessToken, sessionId, 0)\n\t\t}\n\n\t\tthis.loggingInPromiseWrapper = defer()\n\t\t// Wait for either login or cancel\n\t\treturn Promise.race([this.loggingInPromiseWrapper.promise, p]).then(() => ({\n\t\t\tsessionId,\n\t\t\taccessToken: createSessionReturn.accessToken,\n\t\t\tuserId: createSessionReturn.user,\n\t\t}))\n\t}\n\n\tprivate async waitUntilSecondFactorApproved(accessToken: Base64Url, sessionId: IdTuple, retryOnNetworkError: number): Promise<void> {\n\t\tlet secondFactorAuthGetData = createSecondFactorAuthGetData({\n\t\t\taccessToken,\n\t\t})\n\t\ttry {\n\t\t\tconst secondFactorAuthGetReturn = await this.serviceExecutor.get(SecondFactorAuthService, secondFactorAuthGetData)\n\t\t\tif (!this.loginRequestSessionId || !isSameId(this.loginRequestSessionId, sessionId)) {\n\t\t\t\tthrow new CancelledError(\"login cancelled\")\n\t\t\t}\n\n\t\t\tif (secondFactorAuthGetReturn.secondFactorPending) {\n\t\t\t\treturn this.waitUntilSecondFactorApproved(accessToken, sessionId, 0)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof ConnectionError && retryOnNetworkError < 10) {\n\t\t\t\t// Connection error can occur on ios when switching between apps or just as a timeout (our request timeout is shorter than the overall\n\t\t\t\t// auth flow timeout). Just retry in this case.\n\t\t\t\treturn this.waitUntilSecondFactorApproved(accessToken, sessionId, retryOnNetworkError + 1)\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\t/**\n\t * Create external (temporary mailbox for passphrase-protected emails) session and log in.\n\t * Changes internal state to refer to the logged-in user.\n\t */\n\tasync createExternalSession(\n\t\tuserId: Id,\n\t\tpassphrase: string,\n\t\tsalt: Uint8Array,\n\t\tkdfType: KdfType,\n\t\tclientIdentifier: string,\n\t\tpersistentSession: boolean,\n\t): Promise<NewSessionData> {\n\t\tif (this.userFacade.isPartiallyLoggedIn()) {\n\t\t\tthrow new Error(\"user already logged in\")\n\t\t}\n\n\t\tconst userPassphraseKey = await this.deriveUserPassphraseKey({ kdfType, passphrase, salt })\n\t\t// the verifier is always sent as url parameter, so it must be url encoded\n\t\tconst authVerifier = createAuthVerifierAsBase64Url(userPassphraseKey)\n\t\tconst authToken = base64ToBase64Url(uint8ArrayToBase64(sha256Hash(salt)))\n\t\tconst sessionData = createCreateSessionData({\n\t\t\taccessKey: null,\n\t\t\tauthToken,\n\t\t\tauthVerifier,\n\t\t\tclientIdentifier,\n\t\t\tmailAddress: null,\n\t\t\trecoverCodeVerifier: null,\n\t\t\tuser: userId,\n\t\t})\n\t\tlet accessKey: Aes256Key | null = null\n\n\t\tif (persistentSession) {\n\t\t\taccessKey = aes256RandomKey()\n\t\t\tsessionData.accessKey = keyToUint8Array(accessKey)\n\t\t}\n\n\t\tconst createSessionReturn = await this.serviceExecutor.post(SessionService, sessionData)\n\n\t\tlet sessionId = [this.getSessionListId(createSessionReturn.accessToken), this.getSessionElementId(createSessionReturn.accessToken)] as const\n\t\tconst cacheInfo = await this.initCache({\n\t\t\tuserId,\n\t\t\tdatabaseKey: null,\n\t\t\ttimeRangeDays: null,\n\t\t\tforceNewDatabase: true,\n\t\t})\n\t\tconst { user, userGroupInfo, accessToken } = await this.initSession(createSessionReturn.user, createSessionReturn.accessToken, userPassphraseKey)\n\t\tconst credentials = {\n\t\t\tlogin: userId,\n\t\t\taccessToken,\n\t\t\tencryptedPassword: accessKey ? uint8ArrayToBase64(encryptString(accessKey, passphrase)) : null,\n\t\t\tencryptedPassphraseKey: accessKey ? encryptKey(accessKey, userPassphraseKey) : null,\n\t\t\tuserId,\n\t\t\ttype: CredentialType.External,\n\t\t}\n\t\tthis.loginListener.onFullLoginSuccess(SessionType.Login, cacheInfo, credentials)\n\t\treturn {\n\t\t\tuser,\n\t\t\tuserGroupInfo,\n\t\t\tsessionId,\n\t\t\tcredentials: credentials,\n\t\t\tdatabaseKey: null,\n\t\t}\n\t}\n\n\t/**\n\t * Derive a key given a KDF type, passphrase, and salt\n\t */\n\tasync deriveUserPassphraseKey({ kdfType, passphrase, salt }: PassphraseKeyData): Promise<AesKey> {\n\t\tswitch (kdfType) {\n\t\t\tcase KdfType.Bcrypt: {\n\t\t\t\treturn generateKeyFromPassphraseBcrypt(passphrase, salt, KeyLength.b128)\n\t\t\t}\n\t\t\tcase KdfType.Argon2id: {\n\t\t\t\treturn this.argon2idFacade.generateKeyFromPassphrase(passphrase, salt)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Cancels 2FA process. */\n\tasync cancelCreateSession(sessionId: IdTuple): Promise<void> {\n\t\tif (!this.loginRequestSessionId || !isSameId(this.loginRequestSessionId, sessionId)) {\n\t\t\tthrow new Error(\"Trying to cancel session creation but the state is invalid\")\n\t\t}\n\n\t\tconst secondFactorAuthDeleteData = createSecondFactorAuthDeleteData({\n\t\t\tsession: sessionId,\n\t\t})\n\t\tawait this.serviceExecutor\n\t\t\t.delete(SecondFactorAuthService, secondFactorAuthDeleteData)\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, (e) => {\n\t\t\t\t\t// This can happen during some odd behavior in browser where main loop would be blocked by webauthn (hello, FF) and then we would try to\n\t\t\t\t\t// cancel too late. No harm here anyway if the session is already gone.\n\t\t\t\t\tconsole.warn(\"Tried to cancel second factor but it was not there anymore\", e)\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(LockedError, (e) => {\n\t\t\t\t\t// Might happen if we trigger cancel and confirm at the same time.\n\t\t\t\t\tconsole.warn(\"Tried to cancel second factor but it is currently locked\", e)\n\t\t\t\t}),\n\t\t\t)\n\t\tthis.loginRequestSessionId = null\n\t\tthis.loggingInPromiseWrapper?.reject(new CancelledError(\"login cancelled\"))\n\t}\n\n\t/** Finishes 2FA process either using second factor or approving session on another client. */\n\tasync authenticateWithSecondFactor(data: SecondFactorAuthData, host?: string): Promise<void> {\n\t\tawait this.serviceExecutor.post(SecondFactorAuthService, data, { baseUrl: host })\n\t}\n\n\t/**\n\t * Resumes previously created session (using persisted credentials).\n\t * @param credentials the saved credentials to use\n\t * @param externalUserKeyDeriver information for deriving a key (if external user)\n\t * @param databaseKey key to unlock the local database (if enabled)\n\t * @param timeRangeDays the user configured time range for the offline database\n\t */\n\tasync resumeSession(\n\t\tcredentials: Credentials,\n\t\texternalUserKeyDeriver: ExternalUserKeyDeriver | null,\n\t\tdatabaseKey: Uint8Array | null,\n\t\ttimeRangeDays: number | null,\n\t): Promise<ResumeSessionResult> {\n\t\tif (this.userFacade.getUser() != null) {\n\t\t\tthrow new ProgrammingError(\n\t\t\t\t`Trying to resume the session for user ${credentials.userId} while already logged in for ${this.userFacade.getUser()?._id}`,\n\t\t\t)\n\t\t}\n\t\tif (this.asyncLoginState.state !== \"idle\") {\n\t\t\tthrow new ProgrammingError(`Trying to resume the session for user ${credentials.userId} while the asyncLoginState is ${this.asyncLoginState.state}`)\n\t\t}\n\t\tthis.userFacade.setAccessToken(credentials.accessToken)\n\t\t// important: any exit point from here on should deinit the cache if the login hasn't succeeded\n\t\tconst cacheInfo = await this.initCache({\n\t\t\tuserId: credentials.userId,\n\t\t\tdatabaseKey,\n\t\t\ttimeRangeDays,\n\t\t\tforceNewDatabase: false,\n\t\t})\n\t\tconst sessionId = this.getSessionId(credentials)\n\t\ttry {\n\t\t\t// using offline, free, have connection         -> sync login\n\t\t\t// using offline, free, no connection           -> indicate that offline login is not for free customers\n\t\t\t// using offline, premium, have connection      -> async login\n\t\t\t// using offline, premium, no connection        -> async login w/ later retry\n\t\t\t// no offline, free, have connection            -> sync login\n\t\t\t// no offline, free, no connection              -> sync login, fail with connection error\n\t\t\t// no offline, premium, have connection         -> sync login\n\t\t\t// no offline, premium, no connection           -> sync login, fail with connection error\n\n\t\t\t// If a user enables offline storage for the first time, after already having saved credentials\n\t\t\t// then upon their next login, they won't have an offline database available, meaning we have to do\n\t\t\t// synchronous login in order to load all the necessary keys and such\n\t\t\t// the next time they log in they will be able to do asynchronous login\n\t\t\tif (cacheInfo?.isPersistent && !cacheInfo.isNewOfflineDb) {\n\t\t\t\tconst user = await this.entityClient.load(UserTypeRef, credentials.userId)\n\t\t\t\tif (user.accountType !== AccountType.PAID) {\n\t\t\t\t\t// if account is free do not start offline login/async login workflow.\n\t\t\t\t\t// await before return to catch errors here\n\t\t\t\t\treturn await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo).catch(\n\t\t\t\t\t\tofClass(ConnectionError, async () => {\n\t\t\t\t\t\t\tawait this.resetSession()\n\t\t\t\t\t\t\treturn { type: \"error\", reason: ResumeSessionErrorReason.OfflineNotAvailableForFree }\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tthis.userFacade.setUser(user)\n\n\t\t\t\t// Temporary workaround for the transitional period\n\t\t\t\t// Before offline login was enabled (in 3.96.4) we didn't use cache for the login process, only afterwards.\n\t\t\t\t// This could lead to a situation where we never loaded or saved user groupInfo but would try to use it now.\n\t\t\t\t// We can remove this after a few versions when the bulk of people who enabled offline will upgrade.\n\t\t\t\tlet userGroupInfo: GroupInfo\n\t\t\t\ttry {\n\t\t\t\t\tuserGroupInfo = await this.entityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(\"Could not do start login, groupInfo is not cached, falling back to sync login\")\n\t\t\t\t\tif (e instanceof LoginIncompleteError) {\n\t\t\t\t\t\t// await before return to catch the errors here\n\t\t\t\t\t\treturn await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noinspection ExceptionCaughtLocallyJS: we want to make sure we go throw the same exit point\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Start full login async\n\t\t\t\tPromise.resolve().then(() => this.asyncResumeSession(credentials, cacheInfo))\n\t\t\t\tconst data = {\n\t\t\t\t\tuser,\n\t\t\t\t\tuserGroupInfo,\n\t\t\t\t\tsessionId,\n\t\t\t\t}\n\t\t\t\treturn { type: \"success\", data }\n\t\t\t} else {\n\t\t\t\t// await before return to catch errors here\n\t\t\t\treturn await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// If we initialized the cache, but then we couldn't authenticate we should de-initialize\n\t\t\t// the cache again because we will initialize it for the next attempt.\n\t\t\t// It might be also called in initSession but the error can be thrown even before that (e.g. if the db is empty for some reason) so we reset\n\t\t\t// the session here as well, otherwise we might try to open the DB twice.\n\t\t\tawait this.resetSession()\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tprivate getSessionId(credentials: Credentials): IdTuple {\n\t\treturn [this.getSessionListId(credentials.accessToken), this.getSessionElementId(credentials.accessToken)]\n\t}\n\n\tprivate async asyncResumeSession(credentials: Credentials, cacheInfo: CacheInfo): Promise<void> {\n\t\tif (this.asyncLoginState.state === \"running\") {\n\t\t\tthrow new Error(\"finishLoginResume run in parallel\")\n\t\t}\n\t\tthis.asyncLoginState = { state: \"running\" }\n\t\ttry {\n\t\t\tawait this.finishResumeSession(credentials, null, cacheInfo)\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthenticatedError || e instanceof SessionExpiredError) {\n\t\t\t\t// For this type of errors we cannot use credentials anymore.\n\t\t\t\tthis.asyncLoginState = { state: \"idle\" }\n\t\t\t\tawait this.loginListener.onLoginFailure(LoginFailReason.SessionExpired)\n\t\t\t} else {\n\t\t\t\tthis.asyncLoginState = { state: \"failed\", credentials, cacheInfo }\n\t\t\t\tif (!(e instanceof ConnectionError)) await this.sendError(e)\n\t\t\t\tawait this.loginListener.onLoginFailure(LoginFailReason.Error)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async finishResumeSession(\n\t\tcredentials: Credentials,\n\t\texternalUserKeyDeriver: ExternalUserKeyDeriver | null,\n\t\tcacheInfo: CacheInfo,\n\t): Promise<ResumeSessionSuccess> {\n\t\tconst sessionId = this.getSessionId(credentials)\n\t\tconst sessionData = await this.loadSessionData(credentials.accessToken)\n\n\t\tconst accessKey = assertNotNull(sessionData.accessKey, \"no access key on session data!\")\n\t\tconst isExternalUser = externalUserKeyDeriver != null\n\n\t\tlet userPassphraseKey: AesKey\n\t\tlet credentialsWithPassphraseKey: Credentials\n\n\t\t// Previously only the encryptedPassword was stored, now we prefer to use the key if it's already there\n\t\t// and keep passphrase for migrating KDF for now.\n\t\tif (credentials.encryptedPassword) {\n\t\t\tconst passphrase = utf8Uint8ArrayToString(aesDecrypt(accessKey, base64ToUint8Array(credentials.encryptedPassword)))\n\t\t\tif (isExternalUser) {\n\t\t\t\tawait this.checkOutdatedExternalSalt(credentials, sessionData, externalUserKeyDeriver.salt)\n\t\t\t\tuserPassphraseKey = await this.deriveUserPassphraseKey({ ...externalUserKeyDeriver, passphrase })\n\t\t\t} else {\n\t\t\t\tconst passphraseData = await this.loadUserPassphraseKey(credentials.login, passphrase)\n\t\t\t\tuserPassphraseKey = passphraseData.userPassphraseKey\n\t\t\t}\n\t\t\tconst encryptedPassphraseKey = encryptKey(accessKey, userPassphraseKey)\n\t\t\tcredentialsWithPassphraseKey = { ...credentials, encryptedPassphraseKey }\n\t\t} else {\n\t\t\tthrow new ProgrammingError(\"no key or password stored in credentials!\")\n\t\t}\n\n\t\tconst { user, userGroupInfo } = await this.initSession(sessionData.userId, credentials.accessToken, userPassphraseKey)\n\t\tthis.loginListener.onFullLoginSuccess(SessionType.Persistent, cacheInfo, credentialsWithPassphraseKey)\n\n\t\tthis.asyncLoginState = { state: \"idle\" }\n\n\t\tconst data = {\n\t\t\tuser,\n\t\t\tuserGroupInfo,\n\t\t\tsessionId,\n\t\t}\n\n\t\t// We only need to migrate the kdf in case an internal user resumes the session.\n\t\tconst modernKdfType = this.isModernKdfType(asKdfType(user.kdfVersion))\n\t\tif (!isExternalUser && credentials.encryptedPassword != null && !modernKdfType) {\n\t\t\tconst passphrase = utf8Uint8ArrayToString(aesDecrypt(accessKey, base64ToUint8Array(credentials.encryptedPassword)))\n\t\t\tawait this.migrateKdfType(KdfType.Argon2id, passphrase, user)\n\t\t}\n\t\tif (!isExternalUser && !isAdminClient()) {\n\t\t\t// We trigger group key rotation only for internal users.\n\t\t\t// If we have not migrated to argon2 we postpone key rotation until next login\n\t\t\t// instead of reloading the pwKey, which would be updated by the KDF migration.\n\t\t\tawait this.keyRotationFacade.initialize(userPassphraseKey, modernKdfType)\n\t\t}\n\n\t\treturn { type: \"success\", data }\n\t}\n\n\tprivate async initSession(\n\t\tuserId: Id,\n\t\taccessToken: Base64Url,\n\t\tuserPassphraseKey: AesKey,\n\t): Promise<{ user: User; accessToken: string; userGroupInfo: GroupInfo }> {\n\t\t// We might have userId already if:\n\t\t// - session has expired and a new one was created\n\t\t// - if it's a partial login\n\t\tconst userIdFromFormerLogin = this.userFacade.getUser()?._id ?? null\n\n\t\tif (userIdFromFormerLogin && userId !== userIdFromFormerLogin) {\n\t\t\tthrow new Error(\"different user is tried to login in existing other user's session\")\n\t\t}\n\n\t\tthis.userFacade.setAccessToken(accessToken)\n\n\t\ttry {\n\t\t\t// We need to use up-to-date user to make sure that we are not checking for outdated verified against cached user.\n\t\t\tconst user = await this.noncachingEntityClient.load(UserTypeRef, userId)\n\t\t\tawait this.checkOutdatedVerifier(user, accessToken, userPassphraseKey)\n\n\t\t\t// this may be the second time we set user in case we had a partial offline login before\n\t\t\t// we do it unconditionally here, to make sure we unlock the latest user group key right below\n\t\t\tthis.userFacade.setUser(user)\n\t\t\tconst wasFullyLoggedIn = this.userFacade.isFullyLoggedIn()\n\n\t\t\tthis.userFacade.unlockUserGroupKey(userPassphraseKey)\n\t\t\tconst userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo)\n\n\t\t\tawait this.loadEntropy()\n\n\t\t\t// If we have been fully logged in at least once already (probably expired ephemeral session)\n\t\t\t// then we just reconnect and re-download missing events.\n\t\t\t// For new connections we have special handling.\n\t\t\tif (wasFullyLoggedIn) {\n\t\t\t\tthis.eventBusClient.connect(ConnectMode.Reconnect)\n\t\t\t} else {\n\t\t\t\tthis.eventBusClient.connect(ConnectMode.Initial)\n\t\t\t}\n\n\t\t\tawait this.entropyFacade.storeEntropy()\n\t\t\treturn { user, accessToken, userGroupInfo }\n\t\t} catch (e) {\n\t\t\tthis.resetSession()\n\t\t\tthrow e\n\t\t}\n\t}\n\n\t/**\n\t * init an appropriate cache implementation. we will always try to create a persistent cache for persistent sessions and fall back to an ephemeral cache\n\t * in the browser.\n\t *\n\t * @param userId the user for which the cache is created\n\t * @param databaseKey the key to use\n\t * @param timeRangeDays how far into the past the cache keeps data around\n\t * @param forceNewDatabase true if the old database should be deleted if there is one\n\t * @private\n\t */\n\tprivate async initCache({ userId, databaseKey, timeRangeDays, forceNewDatabase }: InitCacheOptions): Promise<CacheInfo> {\n\t\tif (databaseKey != null) {\n\t\t\treturn {\n\t\t\t\tdatabaseKey,\n\t\t\t\t...(await this.cacheInitializer.initialize({\n\t\t\t\t\ttype: \"offline\",\n\t\t\t\t\tuserId,\n\t\t\t\t\tdatabaseKey,\n\t\t\t\t\ttimeRangeDays,\n\t\t\t\t\tforceNewDatabase,\n\t\t\t\t})),\n\t\t\t}\n\t\t} else {\n\t\t\treturn { databaseKey: null, ...(await this.cacheInitializer.initialize({ type: \"ephemeral\", userId })) }\n\t\t}\n\t}\n\n\tprivate async deInitCache(): Promise<void> {\n\t\treturn this.cacheInitializer.deInitialize()\n\t}\n\n\t/**\n\t * Check whether the passed salt for external user is up-to-date (whether an outdated link was used).\n\t */\n\tprivate async checkOutdatedExternalSalt(\n\t\tcredentials: Credentials,\n\t\tsessionData: {\n\t\t\tuserId: Id\n\t\t\taccessKey: AesKey | null\n\t\t},\n\t\texternalUserSalt: Uint8Array,\n\t) {\n\t\tthis.userFacade.setAccessToken(credentials.accessToken)\n\t\tconst user = await this.entityClient.load(UserTypeRef, sessionData.userId)\n\t\tconst latestSaltHash = assertNotNull(user.externalAuthInfo!.latestSaltHash, \"latestSaltHash is not set!\")\n\t\tif (!arrayEquals(latestSaltHash, sha256Hash(externalUserSalt))) {\n\t\t\t// Do not delete session or credentials, we can still use them if the password\n\t\t\t// hasn't been changed.\n\t\t\tthis.resetSession()\n\t\t\tthrow new AccessExpiredError(\"Salt changed, outdated link?\")\n\t\t}\n\t}\n\n\t/**\n\t * Check that the auth verifier is not changed e.g. due to the password change.\n\t * Normally this won't happen for internal users as all sessions are closed on password change. This may happen for external users when the sender has\n\t * changed the password.\n\t * We do not delete all sessions on the server when changing the external password to avoid that an external user is immediately logged out.\n\t *\n\t * @param user Should be up-to-date, i.e., not loaded from cache, but fresh from the server, otherwise an outdated verifier will cause a logout.\n\t */\n\tprivate async checkOutdatedVerifier(user: User, accessToken: string, userPassphraseKey: Aes128Key) {\n\t\tif (uint8ArrayToBase64(user.verifier) !== uint8ArrayToBase64(sha256Hash(createAuthVerifier(userPassphraseKey)))) {\n\t\t\tconsole.log(\"Auth verifier has changed\")\n\t\t\t// delete the obsolete session to make sure it can not be used any more\n\t\t\tawait this.deleteSession(accessToken).catch((e) => console.error(\"Could not delete session\", e))\n\t\t\tawait this.resetSession()\n\t\t\tthrow new NotAuthenticatedError(\"Auth verifier has changed\")\n\t\t}\n\t}\n\n\tprivate async loadUserPassphraseKey(\n\t\tmailAddress: string,\n\t\tpassphrase: string,\n\t): Promise<{\n\t\tkdfType: KdfType\n\t\tuserPassphraseKey: AesKey\n\t}> {\n\t\tmailAddress = mailAddress.toLowerCase().trim()\n\t\tconst saltRequest = createSaltData({ mailAddress })\n\t\tconst saltReturn = await this.serviceExecutor.get(SaltService, saltRequest)\n\t\tconst kdfType = asKdfType(saltReturn.kdfVersion)\n\t\treturn {\n\t\t\tuserPassphraseKey: await this.deriveUserPassphraseKey({ kdfType, passphrase, salt: saltReturn.salt }),\n\t\t\tkdfType,\n\t\t}\n\t}\n\n\t/**\n\t * We use the accessToken that should be deleted for authentication. Therefore it can be invoked while logged in or logged out.\n\t *\n\t * @param pushIdentifier identifier associated with this device, if any, to delete PushIdentifier on the server\n\t */\n\tasync deleteSession(accessToken: Base64Url, pushIdentifier: string | null = null): Promise<void> {\n\t\tlet path = typeRefToPath(SessionTypeRef) + \"/\" + this.getSessionListId(accessToken) + \"/\" + this.getSessionElementId(accessToken)\n\t\tconst sessionTypeModel = await resolveTypeReference(SessionTypeRef)\n\n\t\tconst headers = {\n\t\t\taccessToken: neverNull(accessToken),\n\t\t\tv: sessionTypeModel.version,\n\t\t}\n\t\tconst queryParams: Dict = pushIdentifier == null ? {} : { pushIdentifier }\n\t\treturn this.restClient\n\t\t\t.request(path, HttpMethod.DELETE, {\n\t\t\t\theaders,\n\t\t\t\tresponseType: MediaType.Json,\n\t\t\t\tqueryParams,\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(NotAuthenticatedError, () => {\n\t\t\t\t\tconsole.log(\"authentication failed => session is already closed\")\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\tconsole.log(\"authentication failed => session instance is already deleted\")\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\tprivate getSessionElementId(accessToken: Base64Url): Id {\n\t\tlet byteAccessToken = base64ToUint8Array(base64UrlToBase64(neverNull(accessToken)))\n\t\treturn base64ToBase64Url(uint8ArrayToBase64(sha256Hash(byteAccessToken.slice(GENERATED_ID_BYTES_LENGTH))))\n\t}\n\n\tprivate getSessionListId(accessToken: Base64Url): Id {\n\t\tlet byteAccessToken = base64ToUint8Array(base64UrlToBase64(neverNull(accessToken)))\n\t\treturn base64ToBase64Ext(uint8ArrayToBase64(byteAccessToken.slice(0, GENERATED_ID_BYTES_LENGTH)))\n\t}\n\n\tprivate async loadSessionData(accessToken: Base64Url): Promise<{\n\t\tuserId: Id\n\t\taccessKey: AesKey | null\n\t}> {\n\t\tconst path = typeRefToPath(SessionTypeRef) + \"/\" + this.getSessionListId(accessToken) + \"/\" + this.getSessionElementId(accessToken)\n\t\tconst SessionTypeModel = await resolveTypeReference(SessionTypeRef)\n\n\t\tlet headers = {\n\t\t\taccessToken: accessToken,\n\t\t\tv: SessionTypeModel.version,\n\t\t}\n\t\t// we cannot use the entity client yet because this type is encrypted and we don't have an owner key yet\n\t\treturn this.restClient\n\t\t\t.request(path, HttpMethod.GET, {\n\t\t\t\theaders,\n\t\t\t\tresponseType: MediaType.Json,\n\t\t\t})\n\t\t\t.then((instance) => {\n\t\t\t\tlet session = JSON.parse(instance)\n\t\t\t\treturn {\n\t\t\t\t\tuserId: session.user,\n\t\t\t\t\taccessKey: session.accessKey ? base64ToKey(session.accessKey) : null,\n\t\t\t\t}\n\t\t\t})\n\t}\n\n\t/**\n\t * Loads entropy from the last logout.\n\t */\n\tprivate async loadEntropy(): Promise<void> {\n\t\tconst tutanotaProperties = await this.entityClient.loadRoot(TutanotaPropertiesTypeRef, this.userFacade.getUserGroupId())\n\t\treturn this.entropyFacade.loadEntropy(tutanotaProperties)\n\t}\n\n\t/**\n\t * Change password and/or KDF type for the current user. This will cause all other sessions to be closed.\n\t * @return New password encrypted with accessKey if this is a persistent session or {@code null}  if it's an ephemeral one.\n\t */\n\tasync changePassword(\n\t\tcurrentPasswordKeyData: PassphraseKeyData,\n\t\tnewPasswordKeyDataTemplate: Omit<PassphraseKeyData, \"salt\">,\n\t): Promise<{\n\t\tnewEncryptedPassphrase: Base64\n\t\tnewEncryptedPassphraseKey: Uint8Array\n\t} | null> {\n\t\tconst currentUserPassphraseKey = await this.deriveUserPassphraseKey(currentPasswordKeyData)\n\t\tconst currentAuthVerifier = createAuthVerifier(currentUserPassphraseKey)\n\t\tconst newPasswordKeyData = { ...newPasswordKeyDataTemplate, salt: generateRandomSalt() }\n\n\t\tconst newUserPassphraseKey = await this.deriveUserPassphraseKey(newPasswordKeyData)\n\t\tconst currentUserGroupKey = this.userFacade.getCurrentUserGroupKey()\n\t\tconst pwEncUserGroupKey = encryptKey(newUserPassphraseKey, currentUserGroupKey.object)\n\t\tconst authVerifier = createAuthVerifier(newUserPassphraseKey)\n\t\tconst service = createChangePasswordPostIn({\n\t\t\tcode: null,\n\t\t\tkdfVersion: newPasswordKeyDataTemplate.kdfType,\n\t\t\toldVerifier: currentAuthVerifier,\n\t\t\tpwEncUserGroupKey: pwEncUserGroupKey,\n\t\t\trecoverCodeVerifier: null,\n\t\t\tsalt: newPasswordKeyData.salt,\n\t\t\tverifier: authVerifier,\n\t\t\tuserGroupKeyVersion: String(currentUserGroupKey.version),\n\t\t})\n\n\t\tawait this.serviceExecutor.post(ChangePasswordService, service)\n\n\t\tthis.userFacade.setUserDistKey(currentUserGroupKey.version, newUserPassphraseKey)\n\t\tconst accessToken = assertNotNull(this.userFacade.getAccessToken())\n\t\tconst sessionData = await this.loadSessionData(accessToken)\n\t\tif (sessionData.accessKey != null) {\n\t\t\t// if we have an accessKey, this means we are storing the encrypted password locally, in which case we need to store the new one\n\t\t\tconst newEncryptedPassphrase = uint8ArrayToBase64(encryptString(sessionData.accessKey, newPasswordKeyDataTemplate.passphrase))\n\t\t\tconst newEncryptedPassphraseKey = encryptKey(sessionData.accessKey, newUserPassphraseKey)\n\t\t\treturn { newEncryptedPassphrase, newEncryptedPassphraseKey }\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync deleteAccount(password: string, takeover: string, surveyData: SurveyData | null = null): Promise<void> {\n\t\tconst userSalt = assertNotNull(this.userFacade.getLoggedInUser().salt)\n\n\t\tconst passphraseKeyData = {\n\t\t\tkdfType: asKdfType(this.userFacade.getLoggedInUser().kdfVersion),\n\t\t\tpassphrase: password,\n\t\t\tsalt: userSalt,\n\t\t}\n\t\tconst passwordKey = await this.deriveUserPassphraseKey(passphraseKeyData)\n\t\tconst deleteCustomerData = createDeleteCustomerData({\n\t\t\tauthVerifier: createAuthVerifier(passwordKey),\n\t\t\treason: null,\n\t\t\ttakeoverMailAddress: null,\n\t\t\tundelete: false,\n\t\t\tcustomer: neverNull(neverNull(this.userFacade.getLoggedInUser()).customer),\n\t\t\tsurveyData: surveyData,\n\t\t})\n\n\t\tif (takeover !== \"\") {\n\t\t\tdeleteCustomerData.takeoverMailAddress = takeover\n\t\t} else {\n\t\t\tdeleteCustomerData.takeoverMailAddress = null\n\t\t}\n\t\tawait this.serviceExecutor.delete(CustomerService, deleteCustomerData)\n\t}\n\n\t/** Changes user password to another one using recoverCode instead of the old password. */\n\tasync recoverLogin(mailAddress: string, recoverCode: string, newPassword: string, clientIdentifier: string): Promise<void> {\n\t\tconst recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode))\n\t\tconst recoverCodeVerifier = createAuthVerifier(recoverCodeKey)\n\t\tconst recoverCodeVerifierBase64 = base64ToBase64Url(uint8ArrayToBase64(recoverCodeVerifier))\n\t\tconst sessionData = createCreateSessionData({\n\t\t\taccessKey: null,\n\t\t\tauthToken: null,\n\t\t\tauthVerifier: null,\n\t\t\tclientIdentifier: clientIdentifier,\n\t\t\tmailAddress: mailAddress.toLowerCase().trim(),\n\t\t\trecoverCodeVerifier: recoverCodeVerifierBase64,\n\t\t\tuser: null,\n\t\t})\n\t\t// we need a separate entity rest client because to avoid caching of the user instance which is updated on password change. the web socket is not connected because we\n\t\t// don't do a normal login, and therefore we would not get any user update events. we can not use permanentLogin=false with initSession because caching would be enabled,\n\t\t// and therefore we would not be able to read the updated user\n\t\t// additionally we do not want to use initSession() to keep the LoginFacade stateless (except second factor handling) because we do not want to have any race conditions\n\t\t// when logging in normally after resetting the password\n\t\tconst tempAuthDataProvider: AuthDataProvider = {\n\t\t\tcreateAuthHeaders(): Dict {\n\t\t\t\treturn {}\n\t\t\t},\n\t\t\tisFullyLoggedIn(): boolean {\n\t\t\t\treturn false\n\t\t\t},\n\t\t}\n\t\tconst eventRestClient = new EntityRestClient(\n\t\t\ttempAuthDataProvider,\n\t\t\tthis.restClient,\n\t\t\t() => this.cryptoFacade,\n\t\t\tthis.instanceMapper,\n\t\t\tthis.blobAccessTokenFacade,\n\t\t)\n\t\tconst entityClient = new EntityClient(eventRestClient)\n\t\tconst createSessionReturn = await this.serviceExecutor.post(SessionService, sessionData) // Don't pass email address to avoid proposing to reset second factor when we're resetting password\n\n\t\tconst { userId, accessToken } = await this.waitUntilSecondFactorApprovedOrCancelled(createSessionReturn, null)\n\t\tconst user = await entityClient.load(UserTypeRef, userId, {\n\t\t\textraHeaders: {\n\t\t\t\taccessToken,\n\t\t\t},\n\t\t})\n\t\tif (user.auth == null || user.auth.recoverCode == null) {\n\t\t\tthrow new Error(\"missing recover code\")\n\t\t}\n\t\tconst recoverCodeExtraHeaders = {\n\t\t\taccessToken,\n\t\t\trecoverCodeVerifier: recoverCodeVerifierBase64,\n\t\t}\n\n\t\tconst recoverCodeData = await entityClient.load(RecoverCodeTypeRef, user.auth.recoverCode, { extraHeaders: recoverCodeExtraHeaders })\n\t\ttry {\n\t\t\tconst groupKey = aes256DecryptWithRecoveryKey(recoverCodeKey, recoverCodeData.recoverCodeEncUserGroupKey)\n\t\t\tconst salt = generateRandomSalt()\n\t\t\tconst newKdfType = DEFAULT_KDF_TYPE\n\n\t\t\tconst newPassphraseKeyData = { kdfType: newKdfType, passphrase: newPassword, salt }\n\t\t\tconst userPassphraseKey = await this.deriveUserPassphraseKey(newPassphraseKeyData)\n\t\t\tconst pwEncUserGroupKey = encryptKey(userPassphraseKey, groupKey)\n\t\t\tconst newPasswordVerifier = createAuthVerifier(userPassphraseKey)\n\t\t\tconst postData = createChangePasswordPostIn({\n\t\t\t\tcode: null,\n\t\t\t\tkdfVersion: newKdfType,\n\t\t\t\toldVerifier: null,\n\t\t\t\tsalt: salt,\n\t\t\t\tpwEncUserGroupKey: pwEncUserGroupKey,\n\t\t\t\tverifier: newPasswordVerifier,\n\t\t\t\trecoverCodeVerifier: recoverCodeVerifier,\n\t\t\t\tuserGroupKeyVersion: recoverCodeData.userKeyVersion,\n\t\t\t})\n\n\t\t\tconst extraHeaders = {\n\t\t\t\taccessToken,\n\t\t\t}\n\t\t\tawait this.serviceExecutor.post(ChangePasswordService, postData, { extraHeaders })\n\t\t} finally {\n\t\t\tthis.deleteSession(accessToken)\n\t\t}\n\t}\n\n\t/** Deletes second factors using recoverCode as second factor. */\n\tresetSecondFactors(mailAddress: string, password: string, recoverCode: Hex): Promise<void> {\n\t\treturn this.loadUserPassphraseKey(mailAddress, password).then((passphraseReturn) => {\n\t\t\tconst authVerifier = createAuthVerifierAsBase64Url(passphraseReturn.userPassphraseKey)\n\t\t\tconst recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode))\n\t\t\tconst recoverCodeVerifier = createAuthVerifierAsBase64Url(recoverCodeKey)\n\t\t\tconst deleteData = createResetFactorsDeleteData({\n\t\t\t\tmailAddress,\n\t\t\t\tauthVerifier,\n\t\t\t\trecoverCodeVerifier,\n\t\t\t})\n\t\t\treturn this.serviceExecutor.delete(ResetFactorsService, deleteData)\n\t\t})\n\t}\n\n\ttakeOverDeletedAddress(mailAddress: string, password: string, recoverCode: Hex | null, targetAccountMailAddress: string): Promise<void> {\n\t\treturn this.loadUserPassphraseKey(mailAddress, password).then((passphraseReturn) => {\n\t\t\tconst authVerifier = createAuthVerifierAsBase64Url(passphraseReturn.userPassphraseKey)\n\t\t\tlet recoverCodeVerifier: Base64 | null = null\n\n\t\t\tif (recoverCode) {\n\t\t\t\tconst recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode))\n\t\t\t\trecoverCodeVerifier = createAuthVerifierAsBase64Url(recoverCodeKey)\n\t\t\t}\n\n\t\t\tlet data = createTakeOverDeletedAddressData({\n\t\t\t\tmailAddress,\n\t\t\t\tauthVerifier,\n\t\t\t\trecoverCodeVerifier,\n\t\t\t\ttargetAccountMailAddress,\n\t\t\t})\n\t\t\treturn this.serviceExecutor.post(TakeOverDeletedAddressService, data)\n\t\t})\n\t}\n\n\tgenerateTotpSecret(): Promise<TotpSecret> {\n\t\treturn this.getTotpVerifier().then((totp) => totp.generateSecret())\n\t}\n\n\tgenerateTotpCode(time: number, key: Uint8Array): Promise<number> {\n\t\treturn this.getTotpVerifier().then((totp) => totp.generateTotp(time, key))\n\t}\n\n\tprivate getTotpVerifier(): Promise<TotpVerifier> {\n\t\treturn Promise.resolve(new TotpVerifier())\n\t}\n\n\tasync retryAsyncLogin(): Promise<void> {\n\t\tif (this.asyncLoginState.state === \"running\") {\n\t\t\treturn\n\t\t} else if (this.asyncLoginState.state === \"failed\") {\n\t\t\tawait this.asyncResumeSession(this.asyncLoginState.credentials, this.asyncLoginState.cacheInfo)\n\t\t} else {\n\t\t\tthrow new Error(\"credentials went missing\")\n\t\t}\n\t}\n\n\t/**\n\t * Returns a verifier token, which is proof of password authentication and is valid for a limited time.\n\t * This token will have to be passed back to the server with the appropriate call.\n\t */\n\tasync getVerifierToken(passphrase: string): Promise<string> {\n\t\tconst user = this.userFacade.getLoggedInUser()\n\t\tconst passphraseKey = await this.deriveUserPassphraseKey({\n\t\t\tkdfType: asKdfType(user.kdfVersion),\n\t\t\tpassphrase,\n\t\t\tsalt: assertNotNull(user.salt),\n\t\t})\n\n\t\tconst authVerifier = createAuthVerifier(passphraseKey)\n\t\tconst out = await this.serviceExecutor.post(VerifierTokenService, createVerifierTokenServiceIn({ authVerifier }))\n\t\treturn out.token\n\t}\n}\n"]}